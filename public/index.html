<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Hnefatafl Debug UI</title>
    <style>
    body {
        background-color: #1e1e1e;
        color: #ddd;
        font-family: sans-serif;
        padding: 0.125rem;
    }

    .board {
        display: grid;
        grid-template-columns: repeat(11, 2rem);
        column-gap: 0.1rem;
    }

    .cell {
        width: 2rem;
        height: 2rem;
        display: flex;
        justify-content: center;
        align-items: center;
        border: 1px solid #444;
        border-radius: 0.1rem;
        cursor: pointer;
        background-color: #2c2c2c;
        color: #fff;
    }

    .cell:hover {
        background-color: #3a3a3a;
    }

    .throne {
        background-color: #5a5617 !important;
    }

    .corner {
        background-color: #520000 !important;
    }

    .info, .side-panel {
        margin-bottom: 0.5rem;
    }

    .side-panel > div {
        display: flex;
        flex-direction: column;
        min-width: 0;
    }

    .side-panel ul {
        flex: 1 1 auto;
        overflow: auto;
        height: 10rem;
    }

    input {
        margin-right: 5px;
        background-color: #2a2a2a;
        color: #fff;
        border: 1px solid #555;
        padding: 4px;
    }

    button {
        margin-right: 5px;
        background-color: #333;
        color: #fff;
        border: 1px solid #666;
        padding: 4px 8px;
        cursor: pointer;
    }

    button:hover {
        background-color: #444;
    }

    .controls-row {
        display: flex;
        gap: 20px;
        margin: 20px 0;
        align-items: center;
    }

    .toggle-group {
        display: flex;
        align-items: center;
        gap: 5px;
    }

    pre {
        background: #2b2b2b;
        color: #eee;
        padding: 10px;
        height: 150px;
        overflow: auto;
        border: 1px solid #444;
    }

    ul {
        margin: 0;
        padding: 0;
        max-height: 10rem;
        overflow: auto;
    }

    li {
        padding: 4px 6px;
        border-bottom: 1px solid #444;
        font-family: monospace;
    }

    li:hover {
        background-color: #333;
    }

    .cell.highlight-possible {
        background-color: #4a5a3a !important;
    }

    .cell.highlight-capture {
        background-color: #5a3a3a !important;
    }

    .cell.highlight-selected {
        background-color: #3a4a5a !important;
    }

    /* Modal Styles */
    .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background-color: rgba(0, 0, 0, 0.7);
        backdrop-filter: blur(5px);
        -webkit-backdrop-filter: blur(5px);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
    }

    .modal-content {
        background-color: #2a2a2a;
        border: 1px solid #555;
        border-radius: 8px;
        width: 80vw;
        height: 80vh;
        max-width: 800px;
        max-height: 600px;
        display: flex;
        flex-direction: column;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
    }

    .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 20px;
        border-bottom: 1px solid #555;
        flex-shrink: 0;
    }

    .modal-header h2 {
        margin: 0;
        color: #fff;
    }

    .close-btn {
        background: none;
        border: none;
        color: #ccc;
        font-size: 24px;
        cursor: pointer;
        padding: 0;
        width: 30px;
        height: 30px;
        display: flex;
        justify-content: center;
        align-items: center;
        border-radius: 4px;
    }

    .close-btn:hover {
        background-color: #444;
        color: #fff;
    }

    .modal-body {
        padding: 20px;
        overflow-y: auto;
        flex: 1;
        color: #ddd;
        line-height: 1.6;
    }

    .modal-body h3 {
        color: #fff;
        margin-top: 20px;
        margin-bottom: 10px;
    }

    .modal-body h3:first-child {
        margin-top: 0;
    }

    .modal-body p, .modal-body li {
        margin-bottom: 8px;
    }

    .modal-body ul {
        margin: 8px 0;
        padding-left: 20px;
    }

    .modal-body ul ul {
        margin: 4px 0;
    }

    .modal-body strong {
        color: #fff;
    }

    .modal-body em {
        color: #aaa;
        font-style: italic;
    }
    </style>
</head>
<body>
    <h1>Hnefatafl Debug UI</h1>
    
    <div style="margin: 10px 0;">
        <button id="howToPlayBtn">How to Play</button>
    </div>

    <div class="controls-row">
        <div class="toggle-group">
            <input type="checkbox" id="displayMovesToggle" checked>
            <label for="displayMovesToggle">Display Possible Moves</label>
        </div>
        <div class="toggle-group">
            <input type="checkbox" id="autoValidateToggle">
            <label for="autoValidateToggle">Auto Validate</label>
        </div>
        <div class="toggle-group">
            <input type="checkbox" id="autoApplyToggle">
            <label for="autoApplyToggle">Auto Apply</label>
        </div>
    </div>

    <div id="boardcontainer" style="display: flex; flex-direction: row; gap: 20px;">
        <div id="board" class="board"></div>
        <div class="side-panel" style="display: flex; gap: 20px; align-items: flex-start;">
            <div style="flex: 1;">
                <h3>Current Game</h3>
                <button id="copyGame">Copy Game</button>
                <ul id="currentMoves" style="list-style: none; padding: 0; border: 1px solid #ccc;"></ul>
            </div>
            <div style="flex: 1;">
                <h3>Load Game</h3>
                <div style="display: flex;flex-direction: row">
                    <input id="notationInput" placeholder="Enter game notation string" style="width: 100%; margin-bottom: 5px;">
                    <button id="loadBtn">Load</button>
                </div>
                <ul id="loadedMoves" style="list-style: none; padding: 0; border: 1px solid #ccc;"></ul>
            </div>
        </div>
    </div>

    <div class="info">
        <input id="fromInput" placeholder="From (e.g. E5)">
        <input id="toInput" placeholder="To (e.g. E6)">
        <button id="clearBtn">Clear</button>
        <button id="validateBtn">Validate</button>
        <button id="applyBtn">Apply</button>
    </div>

    <div class="info">
        <div>Current Player: <span id="currentPlayer"></span></div>
        <div>Captured: A: <span id="capturedA"></span>, D: <span id="capturedD"></span></div>
        <div>Status: <span id="gameStatus"></span></div>
    </div>

    <pre id="log"></pre>

    <script type="module">
        import { HnefataflEngine } from '../src/HnefataflEngine.js';
        import { parseMove, parseMoveSequence } from '../src/parser.js';

        const boardEl = document.getElementById('board');
        const fromInput = document.getElementById('fromInput');
        const toInput = document.getElementById('toInput');
        const validateBtn = document.getElementById('validateBtn');
        const applyBtn = document.getElementById('applyBtn');
        const clearBtn = document.getElementById('clearBtn');
        const logEl = document.getElementById('log');
        const currentPlayerEl = document.getElementById('currentPlayer');
        const capturedAEl = document.getElementById('capturedA');
        const capturedDEl = document.getElementById('capturedD');
        const gameStatusEl = document.getElementById('gameStatus');
        const currentMovesList = document.getElementById('currentMoves');
        const loadedMovesList = document.getElementById('loadedMoves');
        const notationInput = document.getElementById('notationInput');
        const loadBtn = document.getElementById('loadBtn');
        const copyGameBtn = document.getElementById('copyGame');
        const displayMovesToggle = document.getElementById('displayMovesToggle');
        const autoValidateToggle = document.getElementById('autoValidateToggle');
        const autoApplyToggle = document.getElementById('autoApplyToggle');
        const howToPlayBtn = document.getElementById('howToPlayBtn');
        const howToPlayModal = document.getElementById('howToPlayModal');
        const closeModalBtn = document.getElementById('closeModalBtn');

        const engine = new HnefataflEngine();
        
        // Track UI state for move highlighting
        let selectedFrom = null;
        let possibleMoves = [];
        let currentHighlights = [];

        function coordToString(x, y) {
            return String.fromCharCode(65 + x) + (11 - y);
        }

        function stringToCoord(str) {
            if (!str || str.length !== 2) return null;
            const x = str.charCodeAt(0) - 65;
            const y = 11 - parseInt(str.charAt(1));
            return { x, y };
        }

        function clearHighlights() {
            currentHighlights.forEach(cell => {
                cell.classList.remove('highlight-possible', 'highlight-capture', 'highlight-selected');
            });
            currentHighlights = [];
        }

        function highlightPossibleMoves(from) {
            clearHighlights();
            possibleMoves = engine.getPossibleMoves(from);
            logEl.textContent = JSON.stringify(possibleMoves, null, 2);

            // Only show highlights if the display toggle is enabled
            if (displayMovesToggle.checked) {
                showHighlights(from);
            }
        }

        function showHighlights(from) {
            // Highlight the selected piece
            const fromCell = boardEl.children[from.y * 11 + from.x];
            fromCell.classList.add('highlight-selected');
            currentHighlights.push(fromCell);
            
            // Highlight possible target squares and captures
            possibleMoves.forEach(move => {
                const toCell = boardEl.children[move.to.y * 11 + move.to.x];
                toCell.classList.add('highlight-possible');
                currentHighlights.push(toCell);
                
                // Highlight pieces that would be captured
                move.captures.forEach(capture => {
                    const captureCell = boardEl.children[capture.y * 11 + capture.x];
                    captureCell.classList.add('highlight-capture');
                    currentHighlights.push(captureCell);
                });
            });
        }

        function toggleHighlightsVisibility() {
            if (displayMovesToggle.checked && selectedFrom && possibleMoves.length > 0) {
                // Show highlights if toggle is on and we have possible moves
                showHighlights(selectedFrom);
            } else {
                // Hide highlights if toggle is off
                clearHighlights();
            }
        }

        function renderMoveList(listEl, moves) {
            listEl.innerHTML = '';
            let player = 'defender';
            for (const move of moves) {
                const li = document.createElement('li');
                const prefix = player === 'defender' ? 'D' : 'A';
                if (move === 'pass') {
                    li.textContent = `${prefix}: P`;
                } else {
                    const from = coordToString(move.from.x, move.from.y);
                    const to = coordToString(move.to.x, move.to.y);
                    const caps = move.captures.length ? `(${move.captures.map(c => coordToString(c.x, c.y)).join('')})` : '';
                    li.textContent = `${prefix}: ${from}-${to}${caps}`;
                    li.style.cursor = 'pointer';
                    li.onclick = () => {
                        fromInput.value = from;
                        toInput.value = to;
                    };
                }
                listEl.appendChild(li);
                player = player === 'defender' ? 'attacker' : 'defender';
            }
        }

        function render() {
            const state = engine.getState();
            boardEl.innerHTML = '';

            state.position.forEach((row, y) => {
                row.forEach((square, x) => {
                    const div = document.createElement('div');
                    div.className = 'cell';
                    if (square.isThrone) div.classList.add('throne')
                    else if (square.isRestricted) div.classList.add('corner');
                    if (square.occupant) {
                        if (square.occupant.type === 'attacker') div.textContent = 'A';
                        else if (square.occupant.type === 'defender') div.textContent = 'D';
                        else if (square.occupant.type === 'king') div.textContent = 'K';
                        else div.textContent = '';
                    } else {
                        div.textContent = '';
                    }
                    div.addEventListener('click', () => {
                        const coord = { x, y };
                        const coordStr = coordToString(x, y);
                        
                        if (!selectedFrom) {
                            // First click - select a piece if it belongs to current player
                            if (square.occupant && (
                                square.occupant.owner === state.currentPlayer ||
                                (state.currentPlayer === 'defender' && square.occupant.type === 'king')
                            )) {
                                selectedFrom = coord;
                                fromInput.value = coordStr;
                                toInput.value = '';
                                highlightPossibleMoves(coord);
                            }
                        } else {
                            // Second click - either select target or change selection
                            if (square.occupant && (
                                square.occupant.owner === state.currentPlayer ||
                                (state.currentPlayer === 'defender' && square.occupant.type === 'king')
                            )) {
                                // Clicking another piece - change selection
                                selectedFrom = coord;
                                fromInput.value = coordStr;
                                toInput.value = '';
                                highlightPossibleMoves(coord);
                            } else {
                                // Clicking empty square or opponent piece - try to move here
                                const isPossibleMove = possibleMoves.some(move => 
                                    move.to.x === x && move.to.y === y
                                );
                                
                                if (isPossibleMove) {
                                    toInput.value = coordStr;
                                    
                                    // Handle auto-apply or auto-validate
                                    if (autoApplyToggle.checked) {
                                        // Auto-apply the move
                                        const move = `${fromInput.value}-${toInput.value}`;
                                        const result = engine.applyMove(move);
                                        logEl.textContent = JSON.stringify(result, null, 2);
                                        
                                        if (result.success) {
                                            // Clear selection and highlights after successful move
                                            selectedFrom = null;
                                            possibleMoves = [];
                                            fromInput.value = '';
                                            toInput.value = '';
                                            clearHighlights();
                                            render();
                                        } else {
                                            // Clear inputs if move fails
                                            selectedFrom = null;
                                            possibleMoves = [];
                                            fromInput.value = '';
                                            toInput.value = '';
                                            clearHighlights();
                                        }
                                    } else if (autoValidateToggle.checked) {
                                        // Auto-validate the move (but don't apply)
                                        const move = `${fromInput.value}-${toInput.value}`;
                                        const result = engine.validateMove(move);
                                        
                                        // Display validation result
                                        if (result.expectedCaptures && result.expectedCaptures.length > 0) {
                                            const captureNotation = result.expectedCaptures.map(c => coordToString(c.x, c.y)).join('');
                                            logEl.textContent = `${JSON.stringify(result, null, 2)}\n\nCaptures: ${captureNotation}`;
                                        } else {
                                            logEl.textContent = JSON.stringify(result, null, 2);
                                        }
                                        
                                        // Keep only the highlights for this specific move if display is enabled
                                        if (displayMovesToggle.checked) {
                                            clearHighlights();
                                            const fromCell = boardEl.children[selectedFrom.y * 11 + selectedFrom.x];
                                            fromCell.classList.add('highlight-selected');
                                            currentHighlights.push(fromCell);
                                            
                                            const toCell = boardEl.children[y * 11 + x];
                                            toCell.classList.add('highlight-possible');
                                            currentHighlights.push(toCell);
                                            
                                            // Highlight only the captures for this specific move
                                            const selectedMove = possibleMoves.find(move => 
                                                move.to.x === x && move.to.y === y
                                            );
                                            if (selectedMove) {
                                                selectedMove.captures.forEach(capture => {
                                                    const captureCell = boardEl.children[capture.y * 11 + capture.x];
                                                    captureCell.classList.add('highlight-capture');
                                                    currentHighlights.push(captureCell);
                                                });
                                            }
                                        }
                                    } else {
                                        // Manual mode - just show highlights for specific move if display is enabled
                                        if (displayMovesToggle.checked) {
                                            clearHighlights();
                                            const fromCell = boardEl.children[selectedFrom.y * 11 + selectedFrom.x];
                                            fromCell.classList.add('highlight-selected');
                                            currentHighlights.push(fromCell);
                                            
                                            const toCell = boardEl.children[y * 11 + x];
                                            toCell.classList.add('highlight-possible');
                                            currentHighlights.push(toCell);
                                            
                                            // Highlight only the captures for this specific move
                                            const selectedMove = possibleMoves.find(move => 
                                                move.to.x === x && move.to.y === y
                                            );
                                            if (selectedMove) {
                                                selectedMove.captures.forEach(capture => {
                                                    const captureCell = boardEl.children[capture.y * 11 + capture.x];
                                                    captureCell.classList.add('highlight-capture');
                                                    currentHighlights.push(captureCell);
                                                });
                                            }
                                        }
                                    }
                                } else {
                                    // Invalid target - clear selection
                                    selectedFrom = null;
                                    possibleMoves = [];
                                    fromInput.value = '';
                                    toInput.value = '';
                                    clearHighlights();
                                }
                            }
                        }
                    });
                    boardEl.appendChild(div);
                });
            });

            currentPlayerEl.textContent = state.currentPlayer;
            capturedAEl.textContent = state.captured.attacker;
            capturedDEl.textContent = state.captured.defender;
            gameStatusEl.textContent = state.status;

            const parsedMoves = state.moveHistory.map((str) => {
                if (str === 'P') return 'pass';
                const move = parseMove(str);
                return move ? move : 'pass';
            });

            renderMoveList(currentMovesList, parsedMoves);
        }

        validateBtn.onclick = () => {
            const move = `${fromInput.value}-${toInput.value}`;
            const result = engine.validateMove(move);
            
            // If there are captures available, display them in the log
            if (result.expectedCaptures && result.expectedCaptures.length > 0) {
                const captureNotation = result.expectedCaptures.map(c => coordToString(c.x, c.y)).join('');
                logEl.textContent = `${JSON.stringify(result, null, 2)}\n\nCaptures: ${captureNotation}`;
            } else {
                logEl.textContent = JSON.stringify(result, null, 2);
            }
        };

        applyBtn.onclick = () => {
            const move = `${fromInput.value}-${toInput.value}`;
            const result = engine.applyMove(move);
            logEl.textContent = JSON.stringify(result, null, 2);
            if (result.success) {
                // Clear selection and highlights after successful move
                selectedFrom = null;
                possibleMoves = [];
                fromInput.value = '';
                toInput.value = '';
                clearHighlights();
                render();
            } else {
                fromInput.value = '';
                toInput.value = '';
            }
        };

        clearBtn.onclick = () => {
            selectedFrom = null;
            possibleMoves = [];
            fromInput.value = '';
            toInput.value = '';
            clearHighlights();
        };

        loadBtn.onclick = () => {
            const input = notationInput.value;
            const parsed = parseMoveSequence(input);
            renderMoveList(loadedMovesList, parsed);
        };

        copyGameBtn.onclick = () => {
            const moveHistory = engine.getState().moveHistory;
            navigator.clipboard.writeText(moveHistory.join(', ')).then(() => {
                alert('Game copied to clipboard!');
            });
        };

        // Toggle event listeners
        displayMovesToggle.onchange = () => {
            toggleHighlightsVisibility();
        };

        // How to Play modal event listeners
        howToPlayBtn.onclick = () => {
            howToPlayModal.style.display = 'flex';
        };

        closeModalBtn.onclick = () => {
            howToPlayModal.style.display = 'none';
        };

        // Close modal when clicking the backdrop
        howToPlayModal.onclick = (e) => {
            if (e.target === howToPlayModal) {
                howToPlayModal.style.display = 'none';
            }
        };

        // Note: Auto Validate and Auto Apply toggles don't need separate event handlers
        // as their state is checked during the click handling logic

        engine.reset();
        render();
    </script>

    <!-- How to Play Modal -->
    <div id="howToPlayModal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h2>How to Play Hnefatafl</h2>
                <button id="closeModalBtn" class="close-btn">&times;</button>
            </div>
            <div class="modal-body">
                <h3>Pronunciation & Origin</h3>
                <p><strong>Hnefatafl</strong> is pronounced "nef-ah-tah-ful" (roughly). It's an ancient Norse board game, also known as "King's Table" or "Viking Chess."</p>
                
                <h3>Historical Context</h3>
                <p>Hnefatafl was played throughout medieval Scandinavia and the broader Viking world. The original rules have been lost to time, so modern versions are reconstructions based on archaeological evidence, board layouts found in ancient sites, and references in medieval literature.</p>
                
                <h3>Game Overview</h3>
                <p>This is an asymmetric strategy game with two sides:</p>
                <ul>
                    <li><strong>Defenders (D)</strong> and the <strong>King (K)</strong> - fewer pieces, start in the center</li>
                    <li><strong>Attackers (A)</strong> - more numerous, start around the edges</li>
                </ul>
                
                <h3>Objective</h3>
                <ul>
                    <li><strong>Defenders win</strong> if the King reaches any edge square of the board</li>
                    <li><strong>Attackers win</strong> if they capture the King or completely surround all defenders</li>
                </ul>
                
                <h3>Basic Rules</h3>
                <ul>
                    <li><strong>Movement:</strong> All pieces move like a rook in chess (horizontally or vertically any number of squares)</li>
                    <li><strong>Captures:</strong> Pieces are captured by being sandwiched between two enemy pieces</li>
                    <li><strong>Special Squares:</strong>
                        <ul>
                            <li><strong>Throne (center, yellow):</strong> Only the King can occupy this square</li>
                            <li><strong>Corners (red):</strong> Act as "hostile" squares for captures, only the King can pass through</li>
                        </ul>
                    </li>
                    <li><strong>King Capture:</strong> The King must be surrounded on all four sides to be captured (or three sides if against the throne/edge)</li>
                </ul>
                
                <h3>Forts</h3>
                <p>Defenders can form protective formations called "forts" where they cannot be captured if properly arranged on the board's edge. <em>Note: Automatic fort detection has not yet been implemented in this version.</em></p>
                
                <h3>How to Use This Interface</h3>
                <ul>
                    <li>Click a piece to select it (must be your piece and your turn)</li>
                    <li>Click a destination square to move there</li>
                    <li>Use the input fields below to manually enter moves (e.g., "E5-E6")</li>
                    <li>Toggle "Display Possible Moves" to see valid moves highlighted</li>
                    <li>Use "Auto Validate" or "Auto Apply" for faster gameplay</li>
                </ul>
            </div>
        </div>
    </div>

</body>
</html>
